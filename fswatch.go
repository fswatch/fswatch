// Package fswatch implements a simple interface for filesystem notifications.
package fswatch

import (
	"errors"
	"os"
	"path/filepath"

	"github.com/fswatch/fswatch/internal"
	"github.com/fswatch/fswatch/internal/poller"
)

// EventType is the type of events generated by a Watcher.
type EventType int

const (
	NOTHING  = EventType(internal.NOTHING)  // nothing happened
	CREATED  = EventType(internal.CREATED)  // something was created
	DELETED  = EventType(internal.DELETED)  // something was deleted
	MOVED    = EventType(internal.MOVED)    // something was renamed/moved
	MODIFIED = EventType(internal.MODIFIED) // contents were modified
	OTHER    = EventType(internal.OTHER)    // something else (metadata?) was modified
)

const OptionGenericPoller = "-generic-poller-"

type Observer interface {
	// Observe the event ev on the watched path.
	// If an error is returned, the observer is not called again.
	Observe(path string, ev EventType) error
}

type Watcher struct {
	w watcher
}

func New(opts map[string]interface{}) *Watcher {
	if opts != nil {
		if _, ok := opts[OptionGenericPoller]; ok {
			return &Watcher{
				w: watcher(poller.New(opts)),
			}
		}
	}

	return &Watcher{
		w: newImpl(opts),
	}
}

// File watches a single file, calling the observer with any events.
func File(path string, obs Observer) (cancel func(), err error) {
	return wrapFiles(impl, []string{path}, obs)
}

// Files watches a list of files, calling the observer with any events.
func Files(paths []string, obs Observer) (cancel func(), err error) {
	return wrapFiles(impl, paths, obs)
}

// Recursively watches all files/folders under the given path, calling the observer with any events.
// Note: a recursive watch is not always supported by the host operating system, in which case
// ErrRecursiveUnsupported is returned. In this situation, this code will function similarly:
//
//   fileset, _ := fswatch.EnumerateFiles(path, true)
//   cancel, _ := fswatch.Files(fileset, obs)
//
// Caveat of the code above: unless newly created files are added to a new watcher, you may
// not receive notifications for changes to newly created files.
func Recursively(path string, obs Observer) (cancel func(), err error) {
	return wrapRecursively(impl, path, obs)
}

// ErrRecursiveUnsupported is returned when the host OS does not support a recursive filesystem watch.
// See the documentation for Recursively for potential workarounds.
var ErrRecursiveUnsupported = errors.New("fswatch: recursive watch not supported")

// EnumerateFiles is a helper function to enumerate files for a call to Files, useful when
// Recursively watching is not supported by the host operating system.
func EnumerateFiles(path string, recursive bool) (files []string, err error) {
	var defErr error
	if !recursive {
		defErr = filepath.SkipDir
	}
	path, err = filepath.Abs(path)
	if err != nil {
		return nil, err
	}
	return files, filepath.Walk(path, func(pp string, d os.FileInfo, err error) error {
		if d.IsDir() {
			if pp == path {
				return nil
			}
			return defErr
		}

		files = append(files, filepath.Join(path, pp))
		return err
	})
}
