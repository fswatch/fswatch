// Package fswatch implements a simple interface for filesystem notifications.
package fswatch

import (
	"github.com/fswatch/fswatch/internal"
	"github.com/fswatch/fswatch/internal/poller"
)

// EventType is the type of events generated by a Watcher.
type EventType int

const (
	NOTHING  = EventType(internal.NOTHING)  // nothing happened
	CREATED  = EventType(internal.CREATED)  // something was created
	DELETED  = EventType(internal.DELETED)  // something was deleted
	MODIFIED = EventType(internal.MODIFIED) // contents were modified
	OTHER    = EventType(internal.OTHER)    // something else (metadata?) was modified
)

const OptionGenericPoller = "-generic-poller-"

func New(opts map[string]interface{}) Interface {
	if opts != nil {
		if _, ok := opts[OptionGenericPoller]; ok {
			return &wrap{
				w: watcher(poller.New(opts)),
			}
		}
	}

	return &wrap{
		w: newImpl(opts),
	}
}

// Interface describes the features of a Filesystem Watch implementation.
type Interface interface {
	// File watches a single file, calling the observer with any events.
	// With a file, the only Events possible are:
	//   - MODIFIED indicates that the contents were modified
	//   - OTHER indicates changes to metadata or other OS features:
	//     permissions, access time, link count, etc.
	//   - DELETED indicates that the watched file was removed.
	//     No further events will be generated for the file.
	File(path string, obs ObserveFunc) (cancel func(), err error)

	// Files watches a list of files, calling the observer with any events.
	// Only MODIFIED, OTHER, and DELETED events will be observed.
	// See the File method for details about these event types.
	Files(paths []string, obs ObserveFunc) (cancel func(), err error)

	// Recursively watches all files/folders under the given path, calling the observer with any events.
	// A recurive watch is the only way to receive CREATED events for new files and folders.
	//
	// Note: a recursive watch is not always supported by the host operating system, in which case
	// ErrRecursiveUnsupported is returned. In this situation, this code will function similarly:
	//
	//   fileset, _ := fswatch.EnumerateFiles(path, true)
	//   cancel, _ := fswatch.Files(fileset, obs)
	//
	// An important caveat of the code above: you will not receive CREATED notifications for new files.
	Recursively(path string, obs ObserveFunc) (cancel func(), err error)
}

// File watches a single file, calling the observer with any events.
// With a file, the only Events possible are:
//   - MODIFIED indicates that the contents were modified
//   - OTHER indicates changes to metadata or other OS features:
//     permissions, access time, link count, etc.
//   - DELETED indicates that the watched file was removed.
//     No further events will be generated for the file.
func File(path string, obs ObserveFunc) (cancel func(), err error) {
	return wrapFiles(impl, []string{path}, obs)
}

// Files watches a list of files, calling the observer with any events.
// Only MODIFIED, OTHER, and DELETED events will be observed.
// See the File method for details about these event types.
func Files(paths []string, obs ObserveFunc) (cancel func(), err error) {
	return wrapFiles(impl, paths, obs)
}
